/**
 * @page c_pack Low-level Pack/Unpack API
 *
 * @ref le_pack.h "API Reference"
 *
 * <HR>
 *
 * This low-level pack/unpack API is intended to support the higher level
 * IPC messaging system, specifically code generated by ifgen.  But it
 * can also be used to hand-pack messages if using the @ref c_messaging
 * API directly.
 *
 * This low-level pack/unpack API supports:
 *   - Packing basic types supported by the IPC system.
 *   - Packing reference types
 *   - Packing arrays of the above types
 *   - Packing strings.
 * It also supports unpacking any of the above.
 */

#ifndef LE_PACK_H_INCLUDE_GUARD
#define LE_PACK_H_INCLUDE_GUARD


// with ARM RVCT the max size of UINTPTR_MAX is signed.
#if UINT32_MAX == UINTPTR_MAX || INT32_MAX == UINTPTR_MAX
#  define IFGEN_PTR32 1
#elif UINT64_MAX == UINTPTR_MAX || INT64_MAX == UINTPTR_MAX
#  define IFGEN_PTR64 1
#else
#  error "Unsupported pointer size -- only 32- and 64-bit are supported for local services."
#endif

//--------------------------------------------------------------------------------------------------
/**
 * Pack Definitions and Types
 */
//--------------------------------------------------------------------------------------------------

//semantic tag type:
typedef uint16_t le_pack_SemanticTag_t;

// le_pack type:
typedef enum le_pack_Type
{
    LE_PACK_TYPE_POS_INTEGER = 0,
    LE_PACK_TYPE_NEG_INTEGER = 1,
    LE_PACK_TYPE_BYTE_STRING = 2,
    LE_PACK_TYPE_TEXT_STRING = 3,
    LE_PACK_TYPE_ITEM_ARRAY = 4,
    LE_PACK_TYPE_SEMANTIC_TAG = 5,
    LE_PACK_TYPE_BOOLEAN = 6,
    LE_PACK_TYPE_DOUBLE = 7,
    LE_PACK_TYPE_INDEF_END = 8,
    LE_PACK_TYPE_INVALID_TYPE = 9,
} le_pack_Type_t;


//--------------------------------------------------------------------------------------------------
/**
 * The maximum size that a type would need when packed.
 */
//--------------------------------------------------------------------------------------------------
#ifdef LE_CONFIG_RPC
#define LE_PACK_UINT8_MAX_SIZE              (1 + sizeof(uint8_t))
#define LE_PACK_UINT16_MAX_SIZE             (1 + sizeof(uint16_t))
#define LE_PACK_UINT32_MAX_SIZE             (1 + sizeof(uint32_t))
#define LE_PACK_UINT64_MAX_SIZE             (1 + sizeof(uint64_t))
#define LE_PACK_INT8_MAX_SIZE               (1 + sizeof(int8_t))
#define LE_PACK_INT16_MAX_SIZE              (1 + sizeof(int16_t))
#define LE_PACK_INT32_MAX_SIZE              (1 + sizeof(int32_t))
#define LE_PACK_INT64_MAX_SIZE              (1 + sizeof(int64_t))
#define LE_PACK_POS_INTEGER_MAX_SIZE        (1 + sizeof(uint64_t))
#define LE_PACK_NEG_INTEGER_MAX_SIZE        (1 + sizeof(int64_t))
#define LE_PACK_SEMANTIC_TAG_MAX_SIZE       (1 + sizeof(le_pack_SemanticTag_t))
#define LE_PACK_BOOL_MAX_SIZE               (1)
#define LE_PACK_DOUBLE_MAX_SIZE             (9)
#define LE_PACK_INDEF_END_MAX_SIZE          (1)
#define LE_PACK_STR_HEADER_MAX_SIZE         (1 + sizeof(uint32_t))
#define LE_PACK_ARRAY_HEADER_MAX_SIZE       (1 + sizeof(uint32_t))
#define LE_PACK_INDEF_ARRAY_HEADER_MAX_SIZE (1)
#define LE_PACK_SIZE_POINTER_TUPLE_MAX_SIZE (1 + 1 + sizeof(size_t) + 1 + sizeof(intptr_t))

#else // no rpc:
#define LE_PACK_UINT8_MAX_SIZE              (sizeof(uint8_t))
#define LE_PACK_UINT16_MAX_SIZE             (sizeof(uint16_t))
#define LE_PACK_UINT32_MAX_SIZE             (sizeof(uint32_t))
#define LE_PACK_UINT64_MAX_SIZE             (sizeof(uint64_t))
#define LE_PACK_INT8_MAX_SIZE               (sizeof(int8_t))
#define LE_PACK_INT16_MAX_SIZE              (sizeof(int16_t))
#define LE_PACK_INT32_MAX_SIZE              (sizeof(int32_t))
#define LE_PACK_INT64_MAX_SIZE              (sizeof(int64_t))
#define LE_PACK_POS_INTEGER_MAX_SIZE        (sizeof(uint64_t))
#define LE_PACK_NEG_INTEGER_MAX_SIZE        (sizeof(int64_t))
#define LE_PACK_SEMANTIC_TAG_MAX_SIZE       (0)
#define LE_PACK_BOOL_MAX_SIZE               (sizeof(bool))
#define LE_PACK_DOUBLE_MAX_SIZE             (sizeof(double))
#define LE_PACK_INDEF_END_MAX_SIZE          (0)
#define LE_PACK_STR_HEADER_MAX_SIZE         (sizeof(uint32_t))
#define LE_PACK_ARRAY_HEADER_MAX_SIZE       (sizeof(uint32_t))
#define LE_PACK_INDEF_ARRAY_HEADER_MAX_SIZE (0)
#define LE_PACK_SIZE_POINTER_TUPLE_MAX_SIZE (sizeof(size_t) + sizeof(intptr_t))
#endif


//--------------------------------------------------------------------------------------------------
/**
 *  Semantic Tags:
 */
//--------------------------------------------------------------------------------------------------
#define LE_PACK_REFERENCE               (2001)

#define LE_PACK_IN_STRING_POINTER       (2002)
#define LE_PACK_OUT_STRING_POINTER      (2003)
#define LE_PACK_IN_BYTE_STR_POINTER     (2004)
#define LE_PACK_OUT_BYTE_STR_POINTER    (2005)

#define LE_PACK_CONTEXT_PTR_REFERENCE   (2006)
#define LE_PACK_ASYNC_HANDLER_REFERENCE (2007)

#define LE_PACK_FILESTREAM_ID           (2008)
#define LE_PACK_FILESTREAM_FLAG         (2009)
#define LE_PACK_FILESTREAM_REQUEST_SIZE (2010)

#define LE_PACK_OUT_STRING_SIZE         (2011)
#define LE_PACK_OUT_BYTE_STR_SIZE       (2012)

#define LE_PACK_OUT_STRING_RESPONSE     (2013)
#define LE_PACK_OUT_BYTE_STR_RESPONSE   (2014)


//--------------------------------------------------------------------------------------------------
/**
 * Internal macros:
 */
//--------------------------------------------------------------------------------------------------
#define _LE_PACK_CBOR_POS_INTEGER   0
#define _LE_PACK_CBOR_NEG_INTEGER   1
#define _LE_PACK_CBOR_BYTE_STRING   2
#define _LE_PACK_CBOR_TEXT_STRING   3
#define _LE_PACK_CBOR_ITEM_ARRAY    4
#define _LE_PACK_CBOR_PAIR_MAP      5
#define _LE_PACK_CBOR_SEMANTIC_TAG  6
#define _LE_PACK_CBOR_PRIMITVE      7

#define _LE_PACK_CBOR_COMPLEX_THRESHOLD    24

#define _LE_PACK_CBOR_PRIMITIVE_FALSE      20
#define _LE_PACK_CBOR_PRIMITIVE_TRUE       21
#define _LE_PACK_CBOR_PRIMITIVE_DOUBLE     27
#define _LE_PACK_CBOR_PRIMITIVE_BREAK      31
#define _LE_PACK_CBOR_PRIMITIVE_INDEFINITE 31




//--------------------------------------------------------------------------------------------------
// Pack functions
//--------------------------------------------------------------------------------------------------

// Packing a simple value is basically the same regardless of type.  But don't use this macro
// directly to get better verification that we're only packing the types we expect
#define LE_PACK_PACK_SIMPLE_VALUE(value)             \
    do {                                             \
        memcpy(*bufferPtr, &(value), sizeof(value)); \
        *bufferPtr = *bufferPtr + sizeof(value);     \
    } while (0)


//--------------------------------------------------------------------------------------------------
/**
 * write bytes
 */
//--------------------------------------------------------------------------------------------------
#define LE_PACK_PACK_SIMPLE_BUFFER(desPtr, length)  \
    do {                                            \
        memcpy(*bufferPtr, desPtr, length);         \
        *bufferPtr += length;                       \
    } while(0)                                      \

//--------------------------------------------------------------------------------------------------
/**
 * pack tiny field
 */
//--------------------------------------------------------------------------------------------------
#define LE_PACK_PACK_TINY_ITEM(major, additional)            \
    do {                                                     \
        *(*bufferPtr) = ((major & 0x7) << 5) | (additional); \
        *bufferPtr += 1;                                     \
    } while(0)                                               \

//--------------------------------------------------------------------------------------------------
/**
 * Pack an integer:
 */
//--------------------------------------------------------------------------------------------------
void _le_pack_packInteger
(
    uint8_t **bufferPtr,
    uint64_t value,
    unsigned int major
);

//--------------------------------------------------------------------------------------------------
/**
 * Pack a negative integer
 */
//--------------------------------------------------------------------------------------------------
void _le_pack_packNegativeInteger
(
    uint8_t **bufferPtr,
    uint64_t value
);

//--------------------------------------------------------------------------------------------------
/**
 * Pack a positive integer
 */
//--------------------------------------------------------------------------------------------------
void _le_pack_packPositiveInteger
(
    uint8_t **bufferPtr,
    uint64_t value
);

//--------------------------------------------------------------------------------------------------
/**
 * Pack a TagID into a buffer, incrementing the buffer pointer and decrementing the
 * available size, as appropriate.
 *
 * @note By making this an inline function, gcc can often optimize out the size check if the buffer
 * size is known at compile time.
 */
//--------------------------------------------------------------------------------------------------
#if LE_CONFIG_RPC
bool le_pack_PackSemanticTag
(
    uint8_t** bufferPtr,
    le_pack_SemanticTag_t value
);
#else
LE_DECLARE_INLINE bool le_pack_PackSemanticTag
(
    uint8_t **bufferPtr,
    le_pack_SemanticTag_t value
)
{
    LE_UNUSED(bufferPtr);
    LE_UNUSED(value);

    return true;
}
#endif


#ifdef LE_CONFIG_RPC
//--------------------------------------------------------------------------------------------------
/**
 * prototype of Out-of-line functions containing rpc specific implementation:
 */
//--------------------------------------------------------------------------------------------------
bool le_pack_PackInt8_rpc(uint8_t** bufferPtr, int8_t value);
bool le_pack_PackInt16_rpc(uint8_t** bufferPtr, int16_t value);
bool le_pack_PackInt32_rpc(uint8_t** bufferPtr, int32_t value);
bool le_pack_PackInt64_rpc(uint8_t** bufferPtr, int64_t value);
bool le_pack_PackDouble_rpc(uint8_t** bufferPtr, double value);
bool le_pack_PackResult_rpc(uint8_t** bufferPtr, le_result_t value);
bool le_pack_PackTaggedSizeUint32Tuple_rpc(uint8_t** bufferPtr, size_t size, uint32_t value,
                                           le_pack_SemanticTag_t tagId);
bool le_pack_PackTaggedSizeUint64Tuple_rpc(uint8_t** bufferPtr, size_t size, uint64_t value,
                                           le_pack_SemanticTag_t tagId);
bool le_pack_PackString_rpc(uint8_t** bufferPtr, const char *stringPtr, uint32_t maxStringCount);
bool le_pack_PackIndefArrayHeader_rpc(uint8_t** bufferPtr);
bool le_pack_PackEndOfIndefArray_rpc(uint8_t** bufferPtr);
bool le_pack_PackBool_rpc(uint8_t** bufferPtr, bool value);
#endif

//--------------------------------------------------------------------------------------------------
/**
 * Pack a uint8_t into a buffer, incrementing the buffer pointer as appropriate.
 *
 * @note By making this an inline function, gcc can often optimize out the size check if the buffer
 * size is known at compile time.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackUint8
(
    uint8_t** bufferPtr,
    uint8_t value
)
{
#ifdef LE_CONFIG_RPC
    _le_pack_packPositiveInteger(bufferPtr, value);
#else
    LE_PACK_PACK_SIMPLE_VALUE(value);
#endif
    return true;
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a uint8_t into a buffer using the specified TagID, incrementing the buffer pointer
 * and decrementing the available size, as appropriate.
 *
 * @note By making this an inline function, gcc can often optimize out the size check if the buffer
 * size is known at compile time.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackTaggedUint8
(
    uint8_t** bufferPtr,
    uint8_t value,
    le_pack_SemanticTag_t tagId
)
{
#ifdef LE_CONFIG_RPC
    le_pack_PackSemanticTag(bufferPtr, tagId);
#else
    LE_UNUSED(tagId);
#endif
    le_pack_PackUint8(bufferPtr, value);
    return true;
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a uint16_t into a buffer, incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackUint16
(
    uint8_t** bufferPtr,
    uint16_t value
)
{
#ifdef LE_CONFIG_RPC
    _le_pack_packPositiveInteger(bufferPtr, value);
#else
    LE_PACK_PACK_SIMPLE_VALUE(value);
#endif
    return true;
}


//--------------------------------------------------------------------------------------------------
/**
 * Pack a uint16_t into a buffer using the specified TagID, incrementing the buffer pointer
 * and decrementing the available size, as appropriate.
 *
 * @note By making this an inline function, gcc can often optimize out the size check if the buffer
 * size is known at compile time.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackTaggedUint16
(
    uint8_t** bufferPtr,
    uint16_t value,
    le_pack_SemanticTag_t tagId
)
{
#ifdef LE_CONFIG_RPC
    le_pack_PackSemanticTag(bufferPtr, tagId);
#else
    LE_UNUSED(tagId);
#endif
    le_pack_PackUint16(bufferPtr, value);
    return true;
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a uint32_t into a buffer, incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackUint32
(
    uint8_t** bufferPtr,
    uint32_t value
)
{
#ifdef LE_CONFIG_RPC
    _le_pack_packPositiveInteger(bufferPtr, value);
#else
    LE_PACK_PACK_SIMPLE_VALUE(value);
#endif
    return true;
}


//--------------------------------------------------------------------------------------------------
/**
 * Pack a uint32_t into a buffer using the specified TagID, incrementing the buffer pointer
 * and decrementing the available size, as appropriate.
 *
 * @note By making this an inline function, gcc can often optimize out the size check if the buffer
 * size is known at compile time.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackTaggedUint32
(
    uint8_t** bufferPtr,
    uint32_t value,
    le_pack_SemanticTag_t tagId
)
{
#ifdef LE_CONFIG_RPC
    le_pack_PackSemanticTag(bufferPtr, tagId);
#else
    LE_UNUSED(tagId);
#endif
    le_pack_PackUint32(bufferPtr, value);
    return true;
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a uint64_t into a buffer, incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackUint64
(
    uint8_t** bufferPtr,
    uint64_t value
)
{
#ifdef LE_CONFIG_RPC
    _le_pack_packPositiveInteger(bufferPtr, value);
#else
    LE_PACK_PACK_SIMPLE_VALUE(value);
#endif
    return true;
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a uint64_t into a buffer using the specified TagID, incrementing the buffer pointer
 * and decrementing the available size, as appropriate.
 *
 * @note By making this an inline function, gcc can often optimize out the size check if the buffer
 * size is known at compile time.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackTaggedUint64
(
    uint8_t** bufferPtr,
    uint64_t value,
    le_pack_SemanticTag_t tagId
)
{
#ifdef LE_CONFIG_RPC
    le_pack_PackSemanticTag(bufferPtr, tagId);
#else
    LE_UNUSED(tagId);
#endif
    le_pack_PackUint64(bufferPtr, value);
    return true;
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a int8_t into a buffer, incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackInt8
(
    uint8_t** bufferPtr,
    int8_t value
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_PackInt8_rpc(bufferPtr, value);
#else
    LE_PACK_PACK_SIMPLE_VALUE(value);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a int8_t into a buffer using the specified TagID, incrementing the buffer pointer
 * and decrementing the available size, as appropriate.
 *
 * @note By making this an inline function, gcc can often optimize out the size check if the buffer
 * size is known at compile time.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackTaggedInt8
(
    uint8_t** bufferPtr,
    int8_t value,
    le_pack_SemanticTag_t tagId
)
{
#ifdef LE_CONFIG_RPC
    le_pack_PackSemanticTag(bufferPtr, tagId);
#else
    LE_UNUSED(tagId);
#endif
    le_pack_PackInt8(bufferPtr, value);
    return true;
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a int16_t into a buffer, incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackInt16
(
    uint8_t** bufferPtr,
    int16_t value
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_PackInt16_rpc(bufferPtr, value);
#else
    LE_PACK_PACK_SIMPLE_VALUE(value);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a int16_t into a buffer using the specified TagID, incrementing the buffer pointer
 * and decrementing the available size, as appropriate.
 *
 * @note By making this an inline function, gcc can often optimize out the size check if the buffer
 * size is known at compile time.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackTaggedInt16
(
    uint8_t** bufferPtr,
    int16_t value,
    le_pack_SemanticTag_t tagId
)
{
#ifdef LE_CONFIG_RPC
    le_pack_PackSemanticTag(bufferPtr, tagId);
#else
    LE_UNUSED(tagId);
#endif
    le_pack_PackInt16(bufferPtr, value);
    return true;
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a int32_t into a buffer, incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackInt32
(
    uint8_t** bufferPtr,
    int32_t value
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_PackInt32_rpc(bufferPtr, value);
#else
    LE_PACK_PACK_SIMPLE_VALUE(value);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a int32_t into a buffer using the specified TagID, incrementing the buffer pointer
 * and decrementing the available size, as appropriate.
 *
 * @note By making this an inline function, gcc can often optimize out the size check if the buffer
 * size is known at compile time.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackTaggedInt32
(
    uint8_t** bufferPtr,
    int32_t value,
    le_pack_SemanticTag_t tagId
)
{
#ifdef LE_CONFIG_RPC
    le_pack_PackSemanticTag(bufferPtr, tagId);
#else
    LE_UNUSED(tagId);
#endif
    le_pack_PackInt32(bufferPtr, value);
    return true;
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a int64_t into a buffer, incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackInt64
(
    uint8_t** bufferPtr,
    int64_t value
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_PackInt64_rpc(bufferPtr, value);
#else
    LE_PACK_PACK_SIMPLE_VALUE(value);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a int64_t into a buffer using the specified TagID, incrementing the buffer pointer
 * and decrementing the available size, as appropriate.
 *
 * @note By making this an inline function, gcc can often optimize out the size check if the buffer
 * size is known at compile time.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackTaggedInt64
(
    uint8_t** bufferPtr,
    int64_t value,
    le_pack_SemanticTag_t tagId
)
{
#ifdef LE_CONFIG_RPC
    le_pack_PackSemanticTag(bufferPtr, tagId);
#else
    LE_UNUSED(tagId);
#endif
    le_pack_PackInt64(bufferPtr, value);
    return true;
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a size_t into a buffer, incrementing the buffer pointer as appropriate.
 *
 * @note Packed sizes are limited to 2^32-1, regardless of platform
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackSize
(
    uint8_t **bufferPtr,
    size_t value
)
{
#ifdef LE_CONFIG_RPC
    _le_pack_packPositiveInteger(bufferPtr, value);
    return true;
#else
    return le_pack_PackUint32(bufferPtr, value);
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack size_t and 32-bit integer tuple into a buffer using the specified TagID,
 * incrementing the buffer pointer
 * and decrementing the available size, as appropriate.
 *
 * @note By making this an inline function, gcc can often optimize out the size check if the buffer
 * size is known at compile time.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackTaggedSizeUint32Tuple
(
    uint8_t** bufferPtr,
    size_t size,
    uint32_t value,
    le_pack_SemanticTag_t tagId
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_PackTaggedSizeUint32Tuple_rpc(bufferPtr, size, value, tagId);
#else
    LE_UNUSED(tagId);
    bool result;
    result = le_pack_PackSize(bufferPtr, size);
    if (result)
    {
        result = le_pack_PackUint32(bufferPtr, value);
    }
    return result;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack size_t and 64-bit integer tuple into a buffer using the specified TagID,
 * incrementing the buffer pointer
 * and decrementing the available size, as appropriate.
 *
 * @note By making this an inline function, gcc can often optimize out the size check if the buffer
 * size is known at compile time.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackTaggedSizeUint64Tuple
(
    uint8_t** bufferPtr,
    size_t size,
    uint64_t value,
    le_pack_SemanticTag_t tagId
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_PackTaggedSizeUint64Tuple_rpc(bufferPtr, size, value, tagId);
#else
    LE_UNUSED(tagId);
    bool result;
    result = le_pack_PackSize(bufferPtr, size);
    if (result)
    {
        result = le_pack_PackUint64(bufferPtr, value);
    }
    return result;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 *  pack a tuple of size and pointer.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackTaggedSizePointerTuple
(
    uint8_t** bufferPtr,
    size_t size,
    void* value,
    le_pack_SemanticTag_t tagId
)
{
#if IFGEN_PTR32
    uint32_t rawValue = (uint32_t)value;
    return le_pack_PackTaggedSizeUint32Tuple(bufferPtr, size, rawValue, tagId);
#elif IFGEN_PTR64
    uint64_t rawValue = (uint64_t)value;
    return le_pack_PackTaggedSizeUint64Tuple(bufferPtr, size, rawValue, tagId);
#else
#  error "Unsupported pointer size -- only 32- and 64-bit are supported for local services."
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a size_t into a buffer using the specified TagID, incrementing the buffer pointer
 * and decrementing the available size, as appropriate.
 *
 * @note Packed sizes are limited to 2^32-1, regardless of platform
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackTaggedSize
(
    uint8_t **bufferPtr,
    size_t value,
    le_pack_SemanticTag_t tagId
)
{
    if (value > UINT32_MAX)
    {
        return false;
    }

    return le_pack_PackTaggedUint32(bufferPtr, value, tagId);
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a bool into a buffer, incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackBool
(
    uint8_t** bufferPtr,
    bool value
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_PackBool_rpc(bufferPtr, value);
#else
    // Force boolean to uint8_t 0 or 1 for packing, regarldess of underlying OS type.
    // Underlying type has been int on some platforms in the past.
    uint8_t simpleValue = ((value)?1:0);
    LE_PACK_PACK_SIMPLE_VALUE(simpleValue);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a bool into a buffer using the specified TagID, incrementing the buffer pointer
 * and decrementing the available size, as appropriate.
 *
 * @note By making this an inline function, gcc can often optimize out the size check if the buffer
 * size is known at compile time.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackTaggedBool
(
    uint8_t** bufferPtr,
    bool value,
    le_pack_SemanticTag_t tagId
)
{
#ifdef LE_CONFIG_RPC
    le_pack_PackSemanticTag(bufferPtr, tagId);
#else
    LE_UNUSED(tagId);
#endif
    le_pack_PackBool(bufferPtr, value);
    return true;
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a char into a buffer, incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackChar
(
    uint8_t** bufferPtr,
    char value
)
{
#ifdef LE_CONFIG_RPC
    _le_pack_packPositiveInteger(bufferPtr, value);
#else
    LE_PACK_PACK_SIMPLE_VALUE(value);
#endif
    return true;
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a char into a buffer using the specified TagID, incrementing the buffer pointer
 * and decrementing the available size, as appropriate.
 *
 * @note By making this an inline function, gcc can often optimize out the size check if the buffer
 * size is known at compile time.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackTaggedChar
(
    uint8_t** bufferPtr,
    char value,
    le_pack_SemanticTag_t tagId
)
{
#ifdef LE_CONFIG_RPC
    le_pack_PackSemanticTag(bufferPtr, tagId);
#else
    LE_UNUSED(tagId);
#endif
    le_pack_PackChar(bufferPtr, value);
    return true;
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a double into a buffer, incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackDouble
(
    uint8_t** bufferPtr,
    double value
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_PackDouble_rpc(bufferPtr, value);
#else
    LE_PACK_PACK_SIMPLE_VALUE(value);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a double into a buffer using the specified TagID, incrementing the buffer pointer
 * and decrementing the available size, as appropriate.
 *
 * @note By making this an inline function, gcc can often optimize out the size check if the buffer
 * size is known at compile time.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackTaggedDouble
(
    uint8_t** bufferPtr,
    double value,
    le_pack_SemanticTag_t tagId
)
{
#ifdef LE_CONFIG_RPC
    le_pack_PackSemanticTag(bufferPtr, tagId);
#else
    LE_UNUSED(tagId);
#endif
    le_pack_PackDouble(bufferPtr, value);
    return true;
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a le_result_t into a buffer, incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackResult
(
    uint8_t** bufferPtr,
    le_result_t value
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_PackResult_rpc(bufferPtr, value);
#else
    LE_PACK_PACK_SIMPLE_VALUE(value);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a le_result_t into a buffer using the specified TagID, incrementing the buffer pointer
 * and decrementing the available size, as appropriate.
 *
 * @note By making this an inline function, gcc can often optimize out the size check if the buffer
 * size is known at compile time.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackTaggedResult
(
    uint8_t** bufferPtr,
    le_result_t value,
    le_pack_SemanticTag_t tagId
)
{
#ifdef LE_CONFIG_RPC
    le_pack_PackSemanticTag(bufferPtr, tagId);
#else
    LE_UNUSED(tagId);
#endif
    le_pack_PackResult(bufferPtr, value);
    return true;
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack le_onoff_t into a buffer, incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackOnOff
(
    uint8_t** bufferPtr,
    le_onoff_t value
)
{
#ifdef LE_CONFIG_RPC
    le_pack_PackUint8(bufferPtr, value);
#else
    LE_PACK_PACK_SIMPLE_VALUE(value);
#endif
    return true;
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack le_onoff_t into a buffer using the specified TagID, incrementing the buffer pointer
 * and decrementing the available size, as appropriate.
 *
 * @note By making this an inline function, gcc can often optimize out the size check if the buffer
 * size is known at compile time.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackTaggedOnOff
(
    uint8_t** bufferPtr,
    le_onoff_t value,
    le_pack_SemanticTag_t tagId
)
{
#ifdef LE_CONFIG_RPC
    le_pack_PackSemanticTag(bufferPtr, tagId);
#else
    LE_UNUSED(tagId);
#endif
    le_pack_PackOnOff(bufferPtr, value);
    return true;
}

#undef LE_PACK_PACK_SIMPLE_VALUE

//--------------------------------------------------------------------------------------------------
/**
 * Pack a reference into a buffer, incrementing the buffer pointer.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackReference
(
    uint8_t** bufferPtr,
    const void* ref
)
{
    size_t refAsInt = (size_t)ref;

    //  All references passed through an API must be safe references (or NULL), so
    // 0-bit will be set and reference will be <= UINT32_MAX.  Size check
    // is performed in pack function.
    if ((refAsInt <= UINT32_MAX) &&
        ((refAsInt & 0x01) ||
         !refAsInt))
    {
#ifdef LE_CONFIG_RPC
        return le_pack_PackTaggedUint32(bufferPtr, (uint32_t)refAsInt, LE_PACK_REFERENCE);
#else
        return le_pack_PackUint32(bufferPtr, (uint32_t)refAsInt);
#endif
    }
    else
    {
        return false;
    }
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a reference into a buffer using the specified TagID, incrementing the buffer pointer
 * and decrementing the available size.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackTaggedReference
(
    uint8_t** bufferPtr,
    const void* ref,
    le_pack_SemanticTag_t tagId
)
{
    size_t refAsInt = (size_t)ref;

    //  All references passed through an API must be safe references (or NULL), so
    // 0-bit will be set and reference will be <= UINT32_MAX.  Size check
    // is performed in pack function.
    if ((refAsInt <= UINT32_MAX) &&
        ((refAsInt & 0x01) ||
         !refAsInt))
    {
        return le_pack_PackTaggedUint32(bufferPtr, (uint32_t)refAsInt, tagId);
    }
    else
    {
        return false;
    }
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a string header
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackStringHeader
(
    uint8_t** bufferPtr,
    size_t stringLen
)
{
#ifdef LE_CONFIG_RPC
    _le_pack_packInteger(bufferPtr, stringLen, _LE_PACK_CBOR_TEXT_STRING);
    return true;
#else
    return le_pack_PackUint32(bufferPtr, stringLen);
#endif
}


//--------------------------------------------------------------------------------------------------
/**
 * Pack a string into a buffer, incrementing the buffer pointer.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackString
(
    uint8_t** bufferPtr,
    const char *stringPtr,
    uint32_t maxStringCount
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_PackString_rpc(bufferPtr, stringPtr, maxStringCount);
#else
    if (!stringPtr)
    {
        return false;
    }

    uint32_t stringLen = strnlen(stringPtr, maxStringCount);
    // String was too long to fit in the buffer -- return false.
    if (stringPtr[stringLen] != '\0')
    {
        return false;
    }
    le_pack_PackUint32(bufferPtr, stringLen);
    LE_PACK_PACK_SIMPLE_BUFFER(stringPtr, stringLen);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a string into a buffer using the specified TagID, incrementing the buffer pointer
 * and decrementing the available size.
 *
 * @note Always decrements available size according to the max possible size used, not actual size
 * used.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackTaggedString
(
    uint8_t** bufferPtr,
    const char *stringPtr,
    uint32_t maxStringCount,
    le_pack_SemanticTag_t tagId
)
{
#ifdef LE_CONFIG_RPC
    le_pack_PackSemanticTag(bufferPtr, tagId);
#else
    LE_UNUSED(tagId);
#endif
    return le_pack_PackString(bufferPtr, stringPtr, maxStringCount);
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack the size information for an array into a buffer, incrementing the buffer pointer.
 *
 * @note Users of this API should generally use LE_PACK_PACKARRAY macro instead which also
 * packs the array data.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackArrayHeader
(
    uint8_t **bufferPtr,
    const void *arrayPtr,
    size_t elementSize,
    size_t arrayCount,
    size_t arrayMaxCount
)
{
    LE_UNUSED(arrayPtr);
    LE_UNUSED(elementSize);

    if (arrayCount > arrayMaxCount)
    {
        return false;
    }

#ifdef LE_CONFIG_RPC
    _le_pack_packInteger(bufferPtr, arrayCount, _LE_PACK_CBOR_ITEM_ARRAY);
#else
    LE_ASSERT(le_pack_PackSize(bufferPtr, arrayCount));
#endif
    return true;
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack an array header with unknown number of elements (inifinite array)
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackIndefArrayHeader
(
    uint8_t** bufferPtr
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_PackIndefArrayHeader_rpc(bufferPtr);
#else
    LE_UNUSED(bufferPtr);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack the end of an indefinite item array
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackEndOfIndefArray
(
    uint8_t** bufferPtr
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_PackEndOfIndefArray_rpc(bufferPtr);
#else
    LE_UNUSED(bufferPtr);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack a string header
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackByteStringHeader
(
    uint8_t** bufferPtr,
    size_t length
)
{
#ifdef LE_CONFIG_RPC
    _le_pack_packInteger(bufferPtr, length, _LE_PACK_CBOR_BYTE_STRING);
    return true;
#else
    return le_pack_PackUint32(bufferPtr, length);
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 *  pack a byte string (Array of uint8, int8, or char)
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackByteString
(
    uint8_t** bufferPtr,
    const void* byteStringPtr,
    uint32_t byteStringCount
)
{
#ifdef LE_CONFIG_RPC
    _le_pack_packInteger(bufferPtr, byteStringCount, _LE_PACK_CBOR_BYTE_STRING);
#else
    le_pack_PackUint32(bufferPtr, byteStringCount);
#endif
    LE_PACK_PACK_SIMPLE_BUFFER(byteStringPtr, byteStringCount);
    return true;
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack tagged inf array header
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackTaggedIndefArrayHeader
(
    uint8_t** bufferPtr,
    le_pack_SemanticTag_t tagId
)
{
#ifdef LE_CONFIG_RPC
    le_pack_PackSemanticTag(bufferPtr, tagId);
#else
    LE_UNUSED(tagId);
#endif
    return le_pack_PackIndefArrayHeader(bufferPtr);
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack the size information for an array into a buffer using the specified TagID,
 * incrementing the buffer pointer and decrementing the available size.
 *
 * @note Users of this API should generally use LE_PACK_PACKARRAY macro instead which also
 * packs the array data.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackTaggedArrayHeader
(
    uint8_t **bufferPtr,
    const void *arrayPtr,
    size_t elementSize,
    size_t arrayCount,
    size_t arrayMaxCount,
    le_pack_SemanticTag_t tagId
)
{
    LE_UNUSED(arrayPtr);
    LE_UNUSED(elementSize);

    if (arrayCount > arrayMaxCount)
    {
        return false;
    }
#ifdef LE_CONFIG_RPC
    le_pack_PackSemanticTag(bufferPtr, tagId);
#else
    LE_UNUSED(tagId);
#endif
    LE_ASSERT(le_pack_PackArrayHeader(bufferPtr,arrayPtr, elementSize, arrayCount, arrayMaxCount));
    return true;
}


//--------------------------------------------------------------------------------------------------
/**
 *  pack a byte string (Array of uint8, int8, or char)
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_PackTaggedByteString
(
    uint8_t** bufferPtr,
    void* byteStringPtr,
    uint32_t byteStringCount
)
{
#ifdef LE_CONFIG_RPC
    _le_pack_packInteger(bufferPtr, byteStringCount, _LE_PACK_CBOR_BYTE_STRING);
#else
    le_pack_PackUint32(bufferPtr, byteStringCount);
#endif
    LE_PACK_PACK_SIMPLE_BUFFER(byteStringPtr, byteStringCount);
    return true;
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack an array into a buffer, incrementing the buffer pointer.
 *
 * @note Will assert if the resulted array exceeds the maximum size allowed.
 */
//--------------------------------------------------------------------------------------------------
#define LE_PACK_PACKARRAY(bufferPtr,                                    \
                          arrayPtr,                                     \
                          arrayCount,                                   \
                          arrayMaxCount,                                \
                          packFunc,                                     \
                          resultPtr)                                    \
    do {                                                                \
        *(resultPtr) = le_pack_PackArrayHeader((bufferPtr),             \
                                               (arrayPtr), sizeof((arrayPtr)[0]), \
                                               (arrayCount), (arrayMaxCount)); \
        if (*(resultPtr))                                               \
        {                                                               \
            uint32_t i;                                                 \
            for (i = 0; i < (arrayCount); ++i)                          \
            {                                                           \
                LE_ASSERT(packFunc((bufferPtr), (arrayPtr)[i]));        \
            }                                                           \
            *(resultPtr) = true;                                        \
        }                                                               \
    } while (0)


//--------------------------------------------------------------------------------------------------
/**
 * Pack an array into a buffer, incrementing the buffer pointer.
 *
 * @note Will assert if the resulted array exceeds the maximum size allowed.
 */
//--------------------------------------------------------------------------------------------------
#define LE_PACK_PACKTAGGEDARRAY(bufferPtr,                                    \
                                arrayPtr,                                     \
                                arrayCount,                                   \
                                arrayMaxCount,                                \
                                packFunc,                                     \
                                tagId,                                        \
                                resultPtr)                                    \
    do {                                                                      \
        *(resultPtr) = le_pack_PackTaggedArrayHeader((bufferPtr),                     \
                                               (arrayPtr), sizeof((arrayPtr)[0]),     \
                                               (arrayCount), (arrayMaxCount), tagId); \
        if (*(resultPtr))                                                     \
        {                                                                     \
            uint32_t i;                                                       \
            for (i = 0; i < (arrayCount); ++i)                                \
            {                                                                 \
                LE_ASSERT(packFunc((bufferPtr), (arrayPtr)[i]));              \
            }                                                                 \
            *(resultPtr) = true;                                              \
        }                                                                     \
    } while (0)

//--------------------------------------------------------------------------------------------------
/**
 * Pack an array of struct into a buffer, incrementing the buffer pointer.
 *
 * @note Will assert if the resulted array of struct exceeds the maximum size allowed.
 */
//--------------------------------------------------------------------------------------------------
#define LE_PACK_PACKSTRUCTARRAY(bufferPtr,                              \
                                 arrayPtr,                              \
                                 arrayCount,                            \
                                 arrayMaxCount,                         \
                                 packFunc,                              \
                                 resultPtr)                             \
    do {                                                                \
        *(resultPtr) = le_pack_PackArrayHeader((bufferPtr),             \
                                               (arrayPtr), sizeof((arrayPtr)[0]), \
                                               (arrayCount), (arrayMaxCount)); \
        if (*(resultPtr))                                               \
        {                                                               \
            uint32_t i;                                                 \
            for (i = 0; i < (arrayCount); ++i)                          \
            {                                                           \
                LE_ASSERT(packFunc((bufferPtr), &((arrayPtr)[i])));     \
            }                                                           \
            *(resultPtr) = true;                                        \
        }                                                               \
    } while (0)

//--------------------------------------------------------------------------------------------------
// Unpack functions
//--------------------------------------------------------------------------------------------------

#define LE_PACK_UNPACK_SIMPLE_VALUE(valuePtr)                \
    do {                                                     \
        memcpy((valuePtr), *bufferPtr, sizeof(*(valuePtr))); \
        *bufferPtr = (*bufferPtr) + sizeof(*(valuePtr));     \
    } while (0)


//--------------------------------------------------------------------------------------------------
/**
 * read bytes
 */
//--------------------------------------------------------------------------------------------------
#define LE_PACK_UNPACK_SIMPLE_BUFFER(srcPtr, length)        \
    do {                                                    \
        memcpy((void*)(srcPtr), *bufferPtr, length);        \
        *bufferPtr += length;                               \
    } while(0)                                              \

//--------------------------------------------------------------------------------------------------
/**
 * Get type.
 *
 * @return
 *      - an le_pack_Type_t enum.
 */
//--------------------------------------------------------------------------------------------------
le_pack_Type_t le_pack_GetType
(
    uint8_t* buffer,                      ///< [IN] buffer pointer
    ssize_t* additionalBytes         ///< [OUT] number of additional bytes
);

//--------------------------------------------------------------------------------------------------
/**
 * unpack tiny field
 */
//--------------------------------------------------------------------------------------------------
#define LE_PACK_UNPACK_TINY_ITEM()                          \
    do {                                                    \
        uint8_t* buffer = *bufferPtr;                       \
        major = (buffer[0] >> 5) & 0x7;                     \
        additional = buffer[0] & 0x1F;                      \
        *bufferPtr += 1;                                    \
    } while(0)                                              \

//--------------------------------------------------------------------------------------------------
/**
 *  unpack positive integer
 */
//--------------------------------------------------------------------------------------------------
bool _le_pack_unpackPositiveInteger(
        uint8_t** bufferPtr,
        uint64_t* valuePtr,
        unsigned int expectedMajor
);


//--------------------------------------------------------------------------------------------------
/**
 *  unpack integer(may be positive or negative)
 */
//--------------------------------------------------------------------------------------------------
bool _le_pack_unpackInteger
(
    uint8_t** bufferPtr,
    int64_t* valuePtr
);

#ifdef LE_CONFIG_RPC
//--------------------------------------------------------------------------------------------------
/**
 *  Protoype of out-of-line functions containing rpc specific implementations:
 */
//--------------------------------------------------------------------------------------------------
bool le_pack_UnpackUint8_rpc(uint8_t** bufferPtr, uint8_t* valuePtr);
bool le_pack_UnpackUint16_rpc(uint8_t** bufferPtr, uint16_t* valuePtr);
bool le_pack_UnpackUint32_rpc(uint8_t** bufferPtr, uint32_t* valuePtr);
bool le_pack_UnpackUint64_rpc(uint8_t** bufferPtr, uint64_t* valuePtr);
bool le_pack_UnpackInt8_rpc(uint8_t** bufferPtr, int8_t* valuePtr);
bool le_pack_UnpackInt16_rpc(uint8_t** bufferPtr, int16_t* valuePtr);
bool le_pack_UnpackInt32_rpc(uint8_t** bufferPtr, int32_t* valuePtr);
bool le_pack_UnpackInt64_rpc(uint8_t** bufferPtr, int64_t* valuePtr);
bool le_pack_UnpackBool_rpc(uint8_t** bufferPtr, bool* valuePtr);
bool le_pack_UnpackChar_rpc(uint8_t** bufferPtr, char* valuePtr);
bool le_pack_UnpackDouble_rpc(uint8_t** bufferPtr, double* valuePtr);
bool le_pack_UnpackResult_rpc(uint8_t** bufferPtr, le_result_t* valuePtr);
bool le_pack_UnpackOnOff_rpc(uint8_t** bufferPtr, le_onoff_t* valuePtr);
bool le_pack_UnpackStringHeader_rpc(uint8_t** bufferPtr, size_t* stringSizePtr);
bool le_pack_UnpackIndefArrayHeader_rpc(uint8_t** bufferPtr);
bool le_pack_UnpackEndOfIndefArray_rpc(uint8_t** bufferPtr);
bool le_pack_UnpackByteStringHeader_rpc(uint8_t** bufferPtr, size_t* lengthPtr);
bool le_pack_UnpackSizeUint32Tuple_rpc(uint8_t** bufferPtr, size_t* sizePtr, uint32_t* valuePtr,
                                       le_pack_SemanticTag_t* semanticTagPtr);
bool le_pack_UnpackSizeUint64Tuple_rpc(uint8_t** bufferPtr, size_t* sizePtr, uint64_t* valuePtr,
                                       le_pack_SemanticTag_t* semanticTagPtr);
bool le_pack_UnpackReference_rpc(uint8_t** bufferPtr, void* refPtr,
                                 le_pack_SemanticTag_t* semanticTagPtr);
bool le_pack_UnpackString_rpc(uint8_t** bufferPtr, char *stringPtr, uint32_t bufferSize,
                              uint32_t maxStringCount);
bool le_pack_UnpackStringHeader_rpc(uint8_t** bufferPtr, size_t* stringSizePtr);
bool le_pack_UnpackArrayHeader_rpc(uint8_t **bufferPtr, const void *arrayPtr, size_t elementSize,
                                   size_t *arrayCountPtr, size_t arrayMaxCount);
bool le_pack_UnpackIndefArrayHeader_rpc(uint8_t** bufferPtr);
bool le_pack_UnpackEndOfIndefArray_rpc(uint8_t** bufferPtr);
bool le_pack_UnpackByteStringHeader_rpc(uint8_t** bufferPtr, size_t* lengthPtr);
bool le_pack_UnpackByteString_rpc(uint8_t** bufferPtr, void *arrayPtr, size_t *arrayCountPtr,
                                  size_t arrayMaxCount);
#endif

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a TagID from a buffer, incrementing the buffer pointer and decrementing the
 * available size, as appropriate.
 */
//--------------------------------------------------------------------------------------------------
#if LE_CONFIG_RPC
bool le_pack_UnpackSemanticTag
(
    uint8_t** bufferPtr,
    le_pack_SemanticTag_t* tagIdPtr
);
#else
LE_DECLARE_INLINE bool le_pack_UnpackSemanticTag
(
    uint8_t** bufferPtr,
    le_pack_SemanticTag_t *tagIdPtr
)
{
    LE_UNUSED(bufferPtr);

    if (tagIdPtr)
    {
        *tagIdPtr = 0;
    }

    return true;
}
#endif

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a TagID from a buffer, incrementing the buffer pointer and decrementing the
 * available size, as appropriate, then check the tag matches the expected tag
 *
 * @note By making this an inline function, gcc can often optimize out the size check if the buffer
 * size is known at compile time.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_CheckSemanticTag
(
    uint8_t** bufferPtr,
    le_pack_SemanticTag_t expectedTagId
)
{
#if LE_CONFIG_RPC
    le_pack_SemanticTag_t tagId;
    return le_pack_UnpackSemanticTag(bufferPtr, &tagId) && (tagId == expectedTagId);
#else
    // No tagging, assume tags always match
    LE_UNUSED(bufferPtr);
    LE_UNUSED(expectedTagId);
    return true;
#endif
}


//--------------------------------------------------------------------------------------------------
/**
 * Unpack a uint8_t from a buffer, incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackUint8
(
    uint8_t** bufferPtr,
    uint8_t* valuePtr
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_UnpackUint8_rpc(bufferPtr, valuePtr);
#else
    LE_PACK_UNPACK_SIMPLE_VALUE(valuePtr);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a uint16_t from a buffer, incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackUint16
(
    uint8_t** bufferPtr,
    uint16_t* valuePtr
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_UnpackUint16_rpc(bufferPtr, valuePtr);
#else
    LE_PACK_UNPACK_SIMPLE_VALUE(valuePtr);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a uint32_t from a buffer, incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackUint32
(
    uint8_t** bufferPtr,
    uint32_t* valuePtr
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_UnpackUint32_rpc(bufferPtr, valuePtr);
#else
    LE_PACK_UNPACK_SIMPLE_VALUE(valuePtr);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a uint64_t from a buffer, incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackUint64
(
    uint8_t** bufferPtr,
    uint64_t* valuePtr
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_UnpackUint64_rpc(bufferPtr, valuePtr);
#else
    LE_PACK_UNPACK_SIMPLE_VALUE(valuePtr);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a int8_t from a buffer, incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackInt8
(
    uint8_t** bufferPtr,
    int8_t* valuePtr
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_UnpackInt8_rpc(bufferPtr, valuePtr);
#else
    LE_PACK_UNPACK_SIMPLE_VALUE(valuePtr);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a int16_t from a buffer, incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackInt16
(
    uint8_t** bufferPtr,
    int16_t* valuePtr
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_UnpackInt16_rpc(bufferPtr, valuePtr);
#else
    LE_PACK_UNPACK_SIMPLE_VALUE(valuePtr);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a int32_t from a buffer, incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackInt32
(
    uint8_t** bufferPtr,
    int32_t* valuePtr
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_UnpackInt32_rpc(bufferPtr, valuePtr);
#else
    LE_PACK_UNPACK_SIMPLE_VALUE(valuePtr);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a int64_t from a buffer, incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackInt64
(
    uint8_t** bufferPtr,
    int64_t* valuePtr
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_UnpackInt64_rpc(bufferPtr, valuePtr);
#else
    LE_PACK_UNPACK_SIMPLE_VALUE(valuePtr);
    return true;
#endif
}


//--------------------------------------------------------------------------------------------------
/**
 * Pack a size_t into a buffer, incrementing the buffer pointer as appropriate.
 *
 * @note Packed sizes are limited to 2^32-1, regardless of platform
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackSize
(
    uint8_t **bufferPtr,
    size_t *valuePtr
)
{
    uint32_t rawValue;

    if (!le_pack_UnpackUint32(bufferPtr, &rawValue))
    {
        return false;
    }

    *valuePtr = rawValue;

    return true;
}

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a uint8_t from a buffer, checking if the tag matches the expected semantic tag
 * and incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackTaggedUint8
(
    uint8_t** bufferPtr,
    uint8_t* valuePtr,
    le_pack_SemanticTag_t tagId
)
{
#ifdef LE_CONFIG_RPC
    if (!le_pack_CheckSemanticTag(bufferPtr, tagId))
    {
        return false;
    }

    return le_pack_UnpackUint8_rpc(bufferPtr, valuePtr);
#else
    LE_UNUSED(bufferPtr);
    LE_UNUSED(tagId);
    LE_PACK_UNPACK_SIMPLE_VALUE(valuePtr);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a uint16_t from a buffer, checking if the tag matches the expected semantic tag
 * and incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackTaggedUint16
(
    uint8_t** bufferPtr,
    uint16_t* valuePtr,
    le_pack_SemanticTag_t tagId
)
{
#ifdef LE_CONFIG_RPC
    if (!le_pack_CheckSemanticTag(bufferPtr, tagId))
    {
        return false;
    }

    return le_pack_UnpackUint16_rpc(bufferPtr, valuePtr);
#else
    LE_UNUSED(bufferPtr);
    LE_UNUSED(tagId);
    LE_PACK_UNPACK_SIMPLE_VALUE(valuePtr);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a uint32_t from a buffer, checking if the tag matches the expected semantic tag
 * and incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackTaggedUint32
(
    uint8_t** bufferPtr,
    uint32_t* valuePtr,
    le_pack_SemanticTag_t tagId
)
{
#ifdef LE_CONFIG_RPC
    if (!le_pack_CheckSemanticTag(bufferPtr, tagId))
    {
        return false;
    }

    return le_pack_UnpackUint32_rpc(bufferPtr, valuePtr);
#else
    LE_UNUSED(bufferPtr);
    LE_UNUSED(tagId);
    LE_PACK_UNPACK_SIMPLE_VALUE(valuePtr);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a uint64_t from a buffer, checking if the tag matches the expected semantic tag
 * and incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackTaggedUint64
(
    uint8_t** bufferPtr,
    uint64_t* valuePtr,
    le_pack_SemanticTag_t tagId
)
{
#ifdef LE_CONFIG_RPC
    if (!le_pack_CheckSemanticTag(bufferPtr, tagId))
    {
        return false;
    }

    return le_pack_UnpackUint64_rpc(bufferPtr, valuePtr);
#else
    LE_UNUSED(bufferPtr);
    LE_UNUSED(tagId);
    LE_PACK_UNPACK_SIMPLE_VALUE(valuePtr);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a int8_t from a buffer, checking if the tag matches the expected semantic tag and
 * incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackTaggedInt8
(
    uint8_t** bufferPtr,
    int8_t* valuePtr,
    le_pack_SemanticTag_t tagId
)
{
#ifdef LE_CONFIG_RPC
    if (!le_pack_CheckSemanticTag(bufferPtr, tagId))
    {
        return false;
    }

    return le_pack_UnpackInt8_rpc(bufferPtr, valuePtr);
#else
    LE_UNUSED(bufferPtr);
    LE_UNUSED(tagId);
    LE_PACK_UNPACK_SIMPLE_VALUE(valuePtr);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a int16_t from a buffer, checking if the tag matches the expected semantic tag
 * and incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackTaggedInt16
(
    uint8_t** bufferPtr,
    int16_t* valuePtr,
    le_pack_SemanticTag_t tagId
)
{
#ifdef LE_CONFIG_RPC
    if (!le_pack_CheckSemanticTag(bufferPtr, tagId))
    {
        return false;
    }

    return le_pack_UnpackInt16_rpc(bufferPtr, valuePtr);
#else
    LE_UNUSED(bufferPtr);
    LE_UNUSED(tagId);
    LE_PACK_UNPACK_SIMPLE_VALUE(valuePtr);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a int32_t from a buffer, checking if the tag matches the expected semantic tag
 * and incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackTaggedInt32
(
    uint8_t** bufferPtr,
    int32_t* valuePtr,
    le_pack_SemanticTag_t tagId
)
{
#ifdef LE_CONFIG_RPC
    if (!le_pack_CheckSemanticTag(bufferPtr, tagId))
    {
        return false;
    }

    return le_pack_UnpackInt32_rpc(bufferPtr, valuePtr);
#else
    LE_UNUSED(bufferPtr);
    LE_UNUSED(tagId);
    LE_PACK_UNPACK_SIMPLE_VALUE(valuePtr);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a int64_t from a buffer, checking if the tag matches the expected semantic tag
 * and incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackTaggedInt64
(
    uint8_t** bufferPtr,
    int64_t* valuePtr,
    le_pack_SemanticTag_t tagId
)
{
#ifdef LE_CONFIG_RPC
    if (!le_pack_CheckSemanticTag(bufferPtr, tagId))
    {
        return false;
    }

    return le_pack_UnpackInt64_rpc(bufferPtr, valuePtr);
#else
    LE_UNUSED(bufferPtr);
    LE_UNUSED(tagId);
    LE_PACK_UNPACK_SIMPLE_VALUE(valuePtr);
    return true;
#endif
}


//--------------------------------------------------------------------------------------------------
/**
 * Pack a size_t into a buffer, checking if the tag matches the expected semantic tag
 * and incrementing the buffer pointer as appropriate.
 *
 * @note Packed sizes are limited to 2^32-1, regardless of platform
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackTaggedSize
(
    uint8_t **bufferPtr,
    size_t *valuePtr,
    le_pack_SemanticTag_t tagId
)
{
    uint32_t rawValue;

    if (!le_pack_CheckSemanticTag(bufferPtr, tagId))
    {
        return false;
    }

    if (!le_pack_UnpackUint32(bufferPtr, &rawValue))
    {
        return false;
    }

    *valuePtr = rawValue;

    return true;
}

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a size_t and 32-bit integer tuple from the buffer,
 * incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackSizeUint32Tuple
(
    uint8_t** bufferPtr,
    size_t* sizePtr,
    uint32_t* valuePtr,
    le_pack_SemanticTag_t* semanticTagPtr
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_UnpackSizeUint32Tuple_rpc(bufferPtr, sizePtr, valuePtr, semanticTagPtr);
#else
    LE_UNUSED(semanticTagPtr);
    bool result;
    result = le_pack_UnpackSize(bufferPtr, sizePtr);
    if (result)
    {
        result = le_pack_UnpackUint32(bufferPtr, valuePtr);
    }
    return result;
#endif
}


//--------------------------------------------------------------------------------------------------
/**
 * Unpack a size_t and 64-bit integer tuple from the buffer,
 * incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackSizeUint64Tuple
(
    uint8_t** bufferPtr,
    size_t* sizePtr,
    uint64_t* valuePtr,
    le_pack_SemanticTag_t* semanticTagPtr
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_UnpackSizeUint64Tuple_rpc(bufferPtr, sizePtr, valuePtr, semanticTagPtr);
#else
    LE_UNUSED(semanticTagPtr);
    bool result;
    result = le_pack_UnpackSize(bufferPtr, sizePtr);
    if (result)
    {
        result = le_pack_UnpackUint64(bufferPtr, valuePtr);
    }
    return result;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a size and pointer tuple from the buffer.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackSizePointerTuple
(
    uint8_t** bufferPtr,
    size_t* sizePtr,
    void** valuePtr,
    le_pack_SemanticTag_t* semanticTagPtr
)
{
#if IFGEN_PTR32
    uint32_t* rawValuePtr = (uint32_t*)valuePtr;
    return le_pack_UnpackSizeUint32Tuple(bufferPtr, sizePtr, rawValuePtr, semanticTagPtr);
#elif IFGEN_PTR64
    uint64_t* rawValuePtr = (uint64_t*)valuePtr;
    return le_pack_UnpackSizeUint64Tuple(bufferPtr, sizePtr, rawValuePtr, semanticTagPtr);
#else
#  error "Unsupported pointer size -- only 32- and 64-bit are supported for local services."
#endif
}




//--------------------------------------------------------------------------------------------------
/**
 * Unpack a bool from a buffer, incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackBool
(
    uint8_t** bufferPtr,
    bool* valuePtr
)
{

#ifdef LE_CONFIG_RPC
    return le_pack_UnpackBool_rpc(bufferPtr, valuePtr);
#else
    // Treat boolean as uint8_t for packing, regardless of underlying OS type.
    // Underlying type has been int on some platforms in the past.
    uint8_t simpleValue;

    memcpy(&simpleValue, *bufferPtr, sizeof(simpleValue));

    *bufferPtr = ((uint8_t* )*bufferPtr) + sizeof(simpleValue);

    // force to true or false
    *valuePtr = !!simpleValue;
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a char from a buffer, incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackChar
(
    uint8_t** bufferPtr,
    char* valuePtr
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_UnpackChar_rpc(bufferPtr, valuePtr);
#else
    LE_PACK_UNPACK_SIMPLE_VALUE(valuePtr);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a double from a buffer, incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackDouble
(
    uint8_t** bufferPtr,
    double* valuePtr
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_UnpackDouble_rpc(bufferPtr, valuePtr);
#else
    LE_PACK_UNPACK_SIMPLE_VALUE(valuePtr);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a le_result_t from a buffer, incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackResult
(
    uint8_t** bufferPtr,
    le_result_t* valuePtr
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_UnpackResult_rpc(bufferPtr, valuePtr);
#else
    LE_PACK_UNPACK_SIMPLE_VALUE(valuePtr);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack le_onoff_t into a buffer, incrementing the buffer pointer as appropriate.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackOnOff
(
    uint8_t** bufferPtr,
    le_onoff_t* valuePtr
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_UnpackOnOff_rpc(bufferPtr, valuePtr);
#else
    LE_PACK_UNPACK_SIMPLE_VALUE(valuePtr);
    return true;
#endif
}

#undef LE_PACK_UNPACK_SIMPLE_VALUE

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a reference from a buffer, incrementing the buffer pointer.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackReference
(
    uint8_t** bufferPtr,        ///< Pointer to the reference.  Declared as void * to allow implicit
    void* refPtr,               ///< conversion from pointer to reference types.
    le_pack_SemanticTag_t* semanticTagPtr ///< [out] semantic tag found before reference.
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_UnpackReference_rpc(bufferPtr, refPtr, semanticTagPtr);
#else
    LE_UNUSED(semanticTagPtr);
    uint32_t refAsInt;
    if (!le_pack_UnpackUint32(bufferPtr, &refAsInt))
    {
        return false;
    }

    //  All references passed through an API must be safe references, so
    // 0-bit will be set.  Check that here to be safe.
    if ((refAsInt & 0x01) ||
        (!refAsInt))
    {
        // Double cast to avoid warnings.
        *(void **)refPtr = (void *)(size_t)refAsInt;
        return true;
    }
    else
    {
        return false;
    }
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a string header
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackStringHeader
(
    uint8_t** bufferPtr,
    size_t* stringSizePtr
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_UnpackStringHeader_rpc(bufferPtr, stringSizePtr);
#else
    if (!le_pack_UnpackSize(bufferPtr, stringSizePtr))
    {
        return false;
    }
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a string from a buffer, incrementing the buffer pointer.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackString
(
    uint8_t** bufferPtr,
    char *stringPtr,
    uint32_t bufferSize,
    uint32_t maxStringCount
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_UnpackString_rpc(bufferPtr, stringPtr, bufferSize, maxStringCount);
#else
    // First get string size
    uint32_t stringSize;
    if (!le_pack_UnpackUint32(bufferPtr, &stringSize))
    {
        return false;
    }
    if ((stringSize > maxStringCount) ||
        (stringSize > bufferSize))
    {
        return false;
    }

    if (!stringPtr)
    {
        // Only allow unpacking into no output buffer if the string is zero sized.
        // Otherwise an output buffer is required.
        if (stringSize)
        {
            return false;
        }
        else
        {
            return true;
        }
    }

    memcpy(stringPtr, *bufferPtr, stringSize);
    stringPtr[stringSize] = '\0';

    *bufferPtr = *bufferPtr + stringSize;

    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Pack the size information for an array into a buffer, incrementing the buffer pointer.
 *
 * @note Users of this API should generally use LE_PACK_PACKARRAY macro instead which also
 * packs the array data.
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackArrayHeader
(
    uint8_t **bufferPtr,
    const void *arrayPtr,
    size_t elementSize,
    size_t *arrayCountPtr,
    size_t arrayMaxCount
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_UnpackArrayHeader_rpc(bufferPtr, arrayPtr, elementSize, arrayCountPtr,
                                          arrayMaxCount);
#else
    LE_UNUSED(elementSize);
    LE_ASSERT(le_pack_UnpackSize(bufferPtr, arrayCountPtr));
    if (*arrayCountPtr > arrayMaxCount)
    {
        return false;
    }
    else if (!arrayPtr)
    {
        // Missing array pointer must match zero sized array.
        return (*arrayCountPtr == 0);
    }

    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * unpack infinite array header
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackIndefArrayHeader
(
    uint8_t** bufferPtr
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_UnpackIndefArrayHeader_rpc(bufferPtr);
#else
    LE_UNUSED(bufferPtr);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * unpack break
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackEndOfIndefArray
(
    uint8_t** bufferPtr
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_UnpackEndOfIndefArray_rpc(bufferPtr);
#else
    LE_UNUSED(bufferPtr);
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Unpack a string header
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackByteStringHeader
(
    uint8_t** bufferPtr,
    size_t* lengthPtr
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_UnpackByteStringHeader_rpc(bufferPtr, lengthPtr);
#else
    if (!le_pack_UnpackSize(bufferPtr, lengthPtr))
    {
        return false;
    }
    return true;
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * unpack a byte string (Array of uint8, int8, char)
 */
//--------------------------------------------------------------------------------------------------
LE_DECLARE_INLINE bool le_pack_UnpackByteString
(
    uint8_t** bufferPtr,
    void *arrayPtr,
    size_t *arrayCountPtr,
    size_t arrayMaxCount
)
{
#ifdef LE_CONFIG_RPC
    return le_pack_UnpackByteString_rpc(bufferPtr, arrayPtr, arrayCountPtr, arrayMaxCount);
#else
    le_pack_UnpackSize(bufferPtr, arrayCountPtr);
    if (*arrayCountPtr > arrayMaxCount)
    {
        return false;
    }
    else if (!arrayPtr)
    {
        // Missing array pointer must match zero sized array.
        return (*arrayCountPtr == 0);
    }
    else
    {
        LE_PACK_UNPACK_SIMPLE_BUFFER(arrayPtr, *arrayCountPtr);
        return true;
    }
#endif
}

//--------------------------------------------------------------------------------------------------
/**
 * Unpack an array into from buffer, incrementing the buffer pointer and decrementing the available
 * size.
 *
 * @note Always decrements available size according to the max possible size used, not actual size
 * used.  Will assert if the resulted array exceeds the maximum size allowed.
 */
//--------------------------------------------------------------------------------------------------
#define LE_PACK_UNPACKARRAY(bufferPtr,                                  \
                            arrayPtr,                                   \
                            arrayCountPtr,                              \
                            arrayMaxCount,                              \
                            unpackFunc,                                 \
                            resultPtr)                                  \
    do {                                                                \
        if (!le_pack_UnpackArrayHeader((bufferPtr),                     \
                                       (arrayPtr), sizeof((arrayPtr)[0]), \
                                       (arrayCountPtr), (arrayMaxCount))) \
        {                                                               \
            *(resultPtr) = false;                                       \
        }                                                               \
        else                                                            \
        {                                                               \
            uint32_t i;                                                 \
            for (i = 0; i < *(arrayCountPtr); ++i)                      \
            {                                                           \
                LE_ASSERT(unpackFunc((bufferPtr), &(arrayPtr)[i]));     \
            }                                                           \
            *(resultPtr) = true;                                        \
        }                                                               \
    } while (0)


//--------------------------------------------------------------------------------------------------
/**
 * Unpack an array of tagged items from buffer, incrementing the buffer pointer and decrementing the
 * available size.
 *
 * @note Always decrements available size according to the max possible size used, not actual size
 * used.  Will assert if the resulted array exceeds the maximum size allowed.
 */
//--------------------------------------------------------------------------------------------------
#define LE_PACK_UNPACKTAGGEDARRAY(bufferPtr,                               \
                                  arrayPtr,                                \
                                  arrayCountPtr,                           \
                                  arrayMaxCount,                           \
                                  unpackFunc,                              \
                                  resultPtr)                               \
    do {                                                                   \
        if (!le_pack_UnpackArrayHeader((bufferPtr),                        \
                                       (arrayPtr), sizeof((arrayPtr)[0]),  \
                                       (arrayCountPtr), (arrayMaxCount)))  \
        {                                                                  \
            *(resultPtr) = false;                                          \
        }                                                                  \
        else                                                               \
        {                                                                  \
            uint32_t i;                                                    \
            for (i = 0; i < *(arrayCountPtr); ++i)                         \
            {                                                              \
                LE_ASSERT(unpackFunc((bufferPtr), &(arrayPtr)[i]), NULL);  \
            }                                                              \
            *(resultPtr) = true;                                           \
        }                                                                  \
    } while (0)


//--------------------------------------------------------------------------------------------------
/**
 * Unpack an array of struct from buffer. Since its logic is the same as that for unpacking an
 * array, here it calls LE_PACK_UNPACKSTRUCTARRAY() to do the work.
 */
//--------------------------------------------------------------------------------------------------
#define LE_PACK_UNPACKSTRUCTARRAY(bufferPtr,                            \
                                  arrayPtr,                             \
                                  arrayCountPtr,                        \
                                  arrayMaxCount,                        \
                                  unpackFunc,                           \
                                  resultPtr)                            \
    LE_PACK_UNPACKARRAY((bufferPtr), (arrayPtr), (arrayCountPtr),       \
                        (arrayMaxCount), (unpackFunc), (resultPtr))

#endif /* LE_PACK_H_INCLUDE_GUARD */
